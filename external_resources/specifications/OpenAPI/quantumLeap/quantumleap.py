# generated by datamodel-codegen:
#   filename:  quantumleap.yml
#   timestamp: 2020-12-04T10:03:01+00:00

from __future__ import annotations

from typing import Any, List, Optional

from pydantic import BaseModel, Field


class Model(BaseModel):
    __root__: Any


class Entity(BaseModel):
    type: str = Field(..., description='The NGSI Entity Type.', example='Room')
    id: str = Field(..., description='The NGSI Entity Id.', example='Kitchen')


class Notification(BaseModel):
    subscriptionId: Optional[str] = Field(None, example='5947d174793fe6f7eb5e3961')
    data: List[Entity]


class IndexArray(BaseModel):
    __root__: List[str] = Field(
        ...,
        description="Array of the timestamps which are indexes of the response for the requested data. It's a parallel array to 'values'. The timestamp will be in the ISO8601 format (e.g. 2010-10-10T07:09:00.792) or in milliseconds since epoch whichever format was used in the input (notification), but ALWAYS in UTC. When using aggregation options, the format of this remains the same, only the semantics will change. For example, if aggrPeriod is day, each index will be a valid timestamp of a moment in the corresponding day.",
    )


class ValuesArray(BaseModel):
    __root__: List = Field(
        ...,
        description="Array of values of the selected attribute, in the same corresponding order of the 'index' array. When using aggregation options, the format of this remains the same, only the semantics will change. For example, if aggrPeriod is day, each value of course may not correspond to original measurements but rather the aggregate of measurements in each day.",
    )


class IndexedValues(BaseModel):
    index: Optional[IndexArray] = None
    values: Optional[ValuesArray] = None


class AttributeValues(BaseModel):
    attrName: Optional[str] = None
    values: Optional[ValuesArray] = None


class EntityIndexedValues(BaseModel):
    entityId: Optional[str] = None
    index: Optional[IndexArray] = None
    values: Optional[ValuesArray] = None
